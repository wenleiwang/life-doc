import{_ as c,r as o,o as d,c as s,b as a,e as n,w as t,d as e,a as h}from"./app-7rGY8hGP.js";const l="/life-doc/assets/a24d4b570a25a1a6ddb2178927c72cf0-UsWH6Tdn.png",u={},i=a("h1",{id:"concurrentmap",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#concurrentmap","aria-hidden":"true"},"#"),e(" ConcurrentMap")],-1),p={class:"table-of-contents"},_=h('<p>线程安全的Map</p><h2 id="类图" tabindex="-1"><a class="header-anchor" href="#类图" aria-hidden="true">#</a> 类图</h2><p><img src="'+l+'" alt=""></p><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2><p>此哈希表的主要设计目标是保持并发可读性（通常是方法 get()，但也包括迭代器和相关方法），同时尽量减少更新争用。次要目标是保持空间消耗与 java.util.HashMap 大致相同或更好，并支持许多线程在空表上的高初始插入率。</p><h2 id="concurrentmap与hashmap的区别" tabindex="-1"><a class="header-anchor" href="#concurrentmap与hashmap的区别" aria-hidden="true">#</a> ConcurrentMap与HashMap的区别</h2><h2 id="concurrentmap是如何实现的" tabindex="-1"><a class="header-anchor" href="#concurrentmap是如何实现的" aria-hidden="true">#</a> ConcurrentMap是如何实现的</h2><h2 id="concurrentmap是怎么分段分组的" tabindex="-1"><a class="header-anchor" href="#concurrentmap是怎么分段分组的" aria-hidden="true">#</a> ConcurrentMap是怎么分段分组的</h2>',8);function m(f,M){const r=o("router-link");return d(),s("div",null,[i,a("nav",p,[a("ul",null,[a("li",null,[n(r,{to:"#类图"},{default:t(()=>[e("类图")]),_:1})]),a("li",null,[n(r,{to:"#介绍"},{default:t(()=>[e("介绍")]),_:1})]),a("li",null,[n(r,{to:"#concurrentmap与hashmap的区别"},{default:t(()=>[e("ConcurrentMap与HashMap的区别")]),_:1})]),a("li",null,[n(r,{to:"#concurrentmap是如何实现的"},{default:t(()=>[e("ConcurrentMap是如何实现的")]),_:1})]),a("li",null,[n(r,{to:"#concurrentmap是怎么分段分组的"},{default:t(()=>[e("ConcurrentMap是怎么分段分组的")]),_:1})])])]),_])}const C=c(u,[["render",m],["__file","ConcurrentMap.html.vue"]]);export{C as default};
