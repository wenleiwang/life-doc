import{_ as r,r as o,o as c,c as l,b as a,e,w as t,d as s,a as i}from"./app-7rGY8hGP.js";const p={},u=a("h1",{id:"java9",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#java9","aria-hidden":"true"},"#"),s(" Java9")],-1),d={class:"table-of-contents"},v=i(`<p>Java9发布于2017年9月22日，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。 详情 看官方文档https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-527735CF-44E1-4144-919B-E7D7CC9CDD4D</p><h2 id="java语言新特性" tabindex="-1"><a class="header-anchor" href="#java语言新特性" aria-hidden="true">#</a> Java语言新特性</h2><h3 id="私有实例方法上允许使用-safevarargs-注释。" tabindex="-1"><a class="header-anchor" href="#私有实例方法上允许使用-safevarargs-注释。" aria-hidden="true">#</a> 私有实例方法上允许使用 @SafeVarargs 注释。</h3><p>允许@SafeVargs私有实例方法。 @SafeVarargs 注释只能应用于不能被覆盖的方法。其中包括静态方法、最终实例方法，以及 Java SE 9 中的新增私有实例方法。</p><h3 id="更简洁的-try-with-resources-语句" tabindex="-1"><a class="header-anchor" href="#更简洁的-try-with-resources-语句" aria-hidden="true">#</a> 更简洁的 try-with-resources 语句</h3><p>允许有效地将最终变量用作try-with-resources语句中的资源。 如果您已经将资源作为变量final或有效final变量，则可以在try-with-resources语句中使用该变量而无需声明新变量。“有效最终”变量是其值在初始化后从未更改过的变量。</p><p>例如，您声明了这两个资源：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// A final resource</span>
<span class="token keyword">final</span> <span class="token class-name">Resource</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">&quot;resource1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// An effectively final resource</span>
<span class="token class-name">Resource</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token string">&quot;resource2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In Java SE 7 or 8, you would declare new variables, like this:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Resource</span> r1 <span class="token operator">=</span> resource1<span class="token punctuation">;</span>
    <span class="token class-name">Resource</span> r2 <span class="token operator">=</span> resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In Java SE 9, you don’t need to declare r1 and r2:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// New and improved try-with-resources statement in Java SE 9</span>
<span class="token keyword">try</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">;</span>
        resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="可以将菱形语法与匿名内部类结合使用" tabindex="-1"><a class="header-anchor" href="#可以将菱形语法与匿名内部类结合使用" aria-hidden="true">#</a> 可以将菱形语法与匿名内部类结合使用</h3><p>如果推断类型的参数类型是可表示的，则允许使用匿名类的菱形。 可以在 Java 程序中编写的类型，例如int或String，称为可表示类型。不能在 Java 程序中编写的编译器内部类型称为不可表示类型。 由于菱形运算符使用的推理结果，可能会出现不可表示的类型。因为使用带有匿名类构造函数的 diamond 推断的类型可能超出类文件中签名属性支持的类型集，因此 Java SE 7 中不允许使用带有匿名类的 diamond。 在 Java SE 9 中，只要推断类型是可表示的，就可以在创建匿名内部类时使用菱形运算符。</p><h3 id="下划线字符不是合法名称" tabindex="-1"><a class="header-anchor" href="#下划线字符不是合法名称" aria-hidden="true">#</a> 下划线字符不是合法名称</h3><p>从 Java SE 8 开始，从合法标识符名称集中删除下划线。 如果您使用下划线字符（“_”）作为标识符，您的源代码将无法再编译。</p><h3 id="支持私有接口方法" tabindex="-1"><a class="header-anchor" href="#支持私有接口方法" aria-hidden="true">#</a> 支持私有接口方法</h3><p>添加对私有接口方法的支持。支持私有接口方法。这种支持允许接口的非抽象方法在它们之间共享代码</p>`,18);function h(k,m){const n=o("router-link");return c(),l("div",null,[u,a("nav",d,[a("ul",null,[a("li",null,[e(n,{to:"#java语言新特性"},{default:t(()=>[s("Java语言新特性")]),_:1}),a("ul",null,[a("li",null,[e(n,{to:"#私有实例方法上允许使用-safevarargs-注释。"},{default:t(()=>[s("私有实例方法上允许使用 @SafeVarargs 注释。")]),_:1})]),a("li",null,[e(n,{to:"#更简洁的-try-with-resources-语句"},{default:t(()=>[s("更简洁的 try-with-resources 语句")]),_:1})]),a("li",null,[e(n,{to:"#可以将菱形语法与匿名内部类结合使用"},{default:t(()=>[s("可以将菱形语法与匿名内部类结合使用")]),_:1})]),a("li",null,[e(n,{to:"#下划线字符不是合法名称"},{default:t(()=>[s("下划线字符不是合法名称")]),_:1})]),a("li",null,[e(n,{to:"#支持私有接口方法"},{default:t(()=>[s("支持私有接口方法")]),_:1})])])])])]),v])}const b=r(p,[["render",h],["__file","java9.html.vue"]]);export{b as default};
