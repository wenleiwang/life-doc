import{_ as i,r as l,o as n,c as d,b as e,e as t,w as s,d as a,a as o}from"./app-7rGY8hGP.js";const h="/life-doc/assets/5a0257273760316d80d49b4a56f0a5db-whcoK-y0.png",c="/life-doc/assets/1d6eb1e73dc15bfe926ba261cfcf9fc0-EfPCoL-o.png",_={},u=e("h1",{id:"redis缓存问题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis缓存问题","aria-hidden":"true"},"#"),a(" Redis缓存问题")],-1),f={class:"table-of-contents"},g=o('<p><img src="'+h+'" alt=""></p><h2 id="_1-使用redis缓存方法" tabindex="-1"><a class="header-anchor" href="#_1-使用redis缓存方法" aria-hidden="true">#</a> 1.使用Redis缓存方法</h2><h3 id="_1-1-简介" tabindex="-1"><a class="header-anchor" href="#_1-1-简介" aria-hidden="true">#</a> 1.1 简介</h3><p>Redis最经常使用的方式就缓存</p><h3 id="_1-2-简单使用" tabindex="-1"><a class="header-anchor" href="#_1-2-简单使用" aria-hidden="true">#</a> 1.2 简单使用</h3><p><img src="'+c+'" alt=""></p><h2 id="_2-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_2-缓存穿透" aria-hidden="true">#</a> 2.缓存穿透</h2><p>假设有一条数据，<strong>数据库根本就不存在</strong>，比如查询<strong>id为-1</strong>的数据，如果前端查询id为-1的请求发过来，Redis中没有，又会去数据库中查询，这样的话，如果有人恶意攻击(比如利用测试软件<strong>瞬间大量的发出此种请求</strong>)，数据库就有可能会崩掉，这就是缓存穿透。</p><h3 id="解决办法" tabindex="-1"><a class="header-anchor" href="#解决办法" aria-hidden="true">#</a> 解决办法</h3><ul><li>对参数进行校验，不合法参数直接拦截。</li><li>既然在数据库中查不到，对此种请求我们设置一个空对象放到Redsi中，设置一个较短的过期时间。</li></ul><h2 id="_3缓存击穿" tabindex="-1"><a class="header-anchor" href="#_3缓存击穿" aria-hidden="true">#</a> 3缓存击穿</h2><p>假设此时<strong>某一个热点key即将过期</strong>了，<strong>在刚好过期的这个时间结点</strong>，若有<strong>大量的访问此热点数据的请求并发发送</strong>过来(比如淘宝单点秒杀)，Redis中查询不到，又会一瞬间的同时访问数据库，也可能瞬间会将数据库搞崩。</p><h3 id="解决办法-1" tabindex="-1"><a class="header-anchor" href="#解决办法-1" aria-hidden="true">#</a> 解决办法</h3><ul><li>对热点key设置为永不过期(对内存不友好)。</li><li>加互斥锁，第一个请求到来先占用此锁，此时其他请求过来拿不到，等第一个请求从数据库查询的结果返回并且存放到Redis中，其余的请求再来访问(即会从Redis中快速拿到数据)。</li></ul><h2 id="_4-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_4-缓存雪崩" aria-hidden="true">#</a> 4.缓存雪崩</h2><p>假设此时正在处于淘宝秒杀的时间段，在<strong>高并发</strong>的情况下，如果<strong>此时大量的缓存失效</strong>，或者<strong>缓存层出现故障</strong>，所有的请求也同时访问数据库，也可能会造成数据库崩掉的状况。</p><h3 id="解决办法-2" tabindex="-1"><a class="header-anchor" href="#解决办法-2" aria-hidden="true">#</a> 解决办法</h3><ul><li>随机设置过期时间。</li><li>不设置过期时间。</li><li>若是集群部署，将热点数据分散到多台Redis服务器当中。</li></ul><hr><p>总结：穿透是redis里<strong>不存在</strong>这个缓存key；击穿是redis<strong>某一个</strong>热点 key <strong>突然</strong>失效，雪崩是<strong>大面积的key缓存失效</strong>；最终的受害者都是数据库。</p><p>完~</p>',21);function p(b,x){const r=l("router-link");return n(),d("div",null,[u,e("nav",f,[e("ul",null,[e("li",null,[t(r,{to:"#_1-使用redis缓存方法"},{default:s(()=>[a("1.使用Redis缓存方法")]),_:1}),e("ul",null,[e("li",null,[t(r,{to:"#_1-1-简介"},{default:s(()=>[a("1.1 简介")]),_:1})]),e("li",null,[t(r,{to:"#_1-2-简单使用"},{default:s(()=>[a("1.2 简单使用")]),_:1})])])]),e("li",null,[t(r,{to:"#_2-缓存穿透"},{default:s(()=>[a("2.缓存穿透")]),_:1}),e("ul",null,[e("li",null,[t(r,{to:"#解决办法"},{default:s(()=>[a("解决办法")]),_:1})])])]),e("li",null,[t(r,{to:"#_3缓存击穿"},{default:s(()=>[a("3缓存击穿")]),_:1}),e("ul",null,[e("li",null,[t(r,{to:"#解决办法-1"},{default:s(()=>[a("解决办法")]),_:1})])])]),e("li",null,[t(r,{to:"#_4-缓存雪崩"},{default:s(()=>[a("4.缓存雪崩")]),_:1}),e("ul",null,[e("li",null,[t(r,{to:"#解决办法-2"},{default:s(()=>[a("解决办法")]),_:1})])])])])]),g])}const R=i(_,[["render",p],["__file","缓存问题.html.vue"]]);export{R as default};
