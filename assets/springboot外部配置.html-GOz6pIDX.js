import{_ as c,r as t,o as r,c as l,b as e,e as a,w as i,d as o,a as p}from"./app-7rGY8hGP.js";const d={},u=e("h1",{id:"外部配置",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#外部配置","aria-hidden":"true"},"#"),o(" 外部配置")],-1),h={class:"table-of-contents"},m=e("p",null,"Spring Boot 允许您将配置外部化，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。",-1),g=e("code",null,"@Value",-1),_={href:"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties",target:"_blank",rel:"noopener noreferrer"},v=e("code",null,"Environment",-1),f=e("code",null,"@ConfigurationProperties",-1),S=p(`<p>Spring Boot 使用一种非常特殊的<code>PropertySource</code>顺序，旨在允许合理地覆盖值。属性按以下顺序考虑（较低项目的值覆盖较早的项目）：</p><ol><li>默认属性（由设置<code>SpringApplication.setDefalutProperties</code>指定</li><li><code>@PropertySource</code>注解在你的<code>@Configuration</code>类。请注意，Application Context刷新之前，这样的属性资源不会添加到<code>Environment</code>。对配置一些属性来说太晚（例如：<code>logging.*</code>和<code>spring.main.*</code>）他们读取在<code>refresh</code>之前</li><li>配置数据（例如：<code>application.properties</code>文件）</li><li><code>RandomValuePropertySource</code>，仅在<code>random.*</code>中的属性</li><li>系统环境变量</li><li>Java系统属性（<code>System.getProperties()</code>）</li><li>来自<code>java:comp/env</code>下的 JNDI 属性</li><li><code>ServletContext</code>初始化参数</li><li><code>ServletConfig</code>初始化参数</li><li>属性来自<code>SPRING_APPLICATION_JSON</code>（嵌入的内联 JSON 在环境变量或系统属性）</li><li>命令行参数</li><li><code>properties</code>属性在你的tests，可用于 在<code>@SpringBootTest</code> 和 应用程序的特定部分的测试注解</li><li><code>@TestPropertySource</code>注解在你的tests</li><li>当devtools被激活时，Devtools全局设置属性在<code>$HOME/.config/spring-boot</code>目录</li></ol><p>配置数据文件可以考虑如下顺序：</p><ol><li>打包在jar中的应用属性（<code>application.properties</code> 和 YAML）</li><li>打包在jar中的特定应用属性（<code>appliction.properties={profile}.properties</code>和YAML）</li><li>打包 jar（<code>application.properties</code>和 YAML 变体）之外的应用程序属性。</li><li>打包的 jar（<code>application-{profile}.properties</code>和 YAML 变体）之外的特定于配置文件的应用程序属性。</li></ol><h2 id="命令行配置属性" tabindex="-1"><a class="header-anchor" href="#命令行配置属性" aria-hidden="true">#</a> 命令行配置属性</h2><p>默认SpringApplication转换以<code>--</code>开头的命令行操作参数（<code>--server.port=9000</code>）为一个<code>property</code>并把它们添加到Spring的<code>Environment</code></p><p>如上所述，命令行参数配置属性优先级高于以文件为基础的属性</p><p>如果不想使用命令行配置属性，可以通过<code>SpringApplication.setAddCommandLineProperties(false)</code>关闭他们</p><h2 id="json-应用程序属性" tabindex="-1"><a class="header-anchor" href="#json-应用程序属性" aria-hidden="true">#</a> JSON 应用程序属性</h2><p>环境变量和系统属性通常有限制，一些属性名不能被使用。为了解决这个，SpringBoot 允许你使用编写一单个的 JSON 结构块的属性</p><p>当你的应用启动，任何<code>spring.application.json</code>或<code>SPRING_APPLICATION_JSON</code>属性将解析并添加到<code>Environment</code></p><p>举例：</p><p><code>SPRING_APPLICATION_JSON</code>属性能通过shell命令行提供一个环境变量</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token assign-left variable">SPRING_APPLICATION_JSON</span><span class="token operator">=</span><span class="token string">&#39;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#39;</span> <span class="token function">java</span> <span class="token parameter variable">-jar</span> myapp.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样最终会在Spring环境中<code>my.name=test</code>使用</p><p>相同的 JSON 也能通过系统属性提供</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">java</span> <span class="token parameter variable">-Dspring.application.json</span><span class="token operator">=</span><span class="token string">&#39;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#39;</span> <span class="token parameter variable">-jar</span> myapp.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者能使用命令行参数提供</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">java</span> <span class="token parameter variable">-jar</span> myapp.jar <span class="token parameter variable">--spring.application.json</span><span class="token operator">=</span><span class="token string">&#39;{&quot;my&quot;:{&quot;name&quot;:&quot;test&quot;}}&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果你部署一个经典的应用服务，你也可以使用 JNDI 变量名<code>java:comp/env/spring.application.json</code></p><h2 id="外部的应用配置文件" tabindex="-1"><a class="header-anchor" href="#外部的应用配置文件" aria-hidden="true">#</a> 外部的应用配置文件</h2><p>Spring Boot将自动发现和加载<code>application.properties</code>和<code>application.yaml</code>文件通过如下位置在你的应用启动时：</p><ol><li>从类路径 <ol><li>类路径跟</li><li>类路径<code>/config</code>包下</li></ol></li><li>从当前目录 <ol><li>当前目录</li><li>当前目录下<code>/config</code>子目录</li><li><code>/config</code>子目录的直接子目录</li></ol></li></ol><p>这个列表按优先级排序（后面的值覆盖前面的值）文档（从加载文件）作为<code>PropertySources</code>到Spring的<code>Environment</code></p>`,24);function b(N,j){const n=t("router-link"),s=t("ExternalLinkIcon");return r(),l("div",null,[u,e("nav",h,[e("ul",null,[e("li",null,[a(n,{to:"#命令行配置属性"},{default:i(()=>[o("命令行配置属性")]),_:1})]),e("li",null,[a(n,{to:"#json-应用程序属性"},{default:i(()=>[o("JSON 应用程序属性")]),_:1})]),e("li",null,[a(n,{to:"#外部的应用配置文件"},{default:i(()=>[o("外部的应用配置文件")]),_:1})])])]),m,e("p",null,[o("属性值可以通过使用注解直接注入到你的 bean 中"),g,o("，通过 Spring 的"),e("a",_,[o("抽象"),a(s)]),v,o("访问，或者通过."),f]),S])}const P=c(d,[["render",b],["__file","springboot外部配置.html.vue"]]);export{P as default};
