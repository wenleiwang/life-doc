import{_ as i,o as l,c as t,a as e}from"./app-7rGY8hGP.js";const a={},c=e('<h1 id="抽象类和接口" tabindex="-1"><a class="header-anchor" href="#抽象类和接口" aria-hidden="true">#</a> 抽象类和接口</h1><p>jdk1.8之前</p><p>抽象类</p><ol><li>单继承</li><li>变量类型不限（静态变量+非静态变量）</li><li>函数类型不限（静态函数+非静态函数）</li><li>非静态函数包含没有方法体的抽象函数. 有方法体的普通函数</li><li>子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法</li><li>可以有main方法；不可以new一个抽象类</li><li>可以有构造器</li></ol><p>接口</p><ol><li>多实现</li><li>变量类型默认且只能为为public static final</li><li>函数类型默认且只能为public，只能有public类型的静态成员函数</li><li>非静态成员函数没有方法体，静态成员函数有方法体</li><li>子类必须实现所有接口函数</li><li>可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数</li><li>没有构造器</li></ol><p>抽象类中的抽象方法(其前有 abstract1修饰)不能用 private、 static、 synchronized、native访回修饰符修饰。</p><ol><li>private 抽象方法没有方法体,是用来被继承的,所以不能用 private修饰; 2.static static修饰的方法可以通过类名来访间该方法(即该方法的方法体),抽象方法用sttic修饰没有意义;</li><li>synchronized 该关键字是为该方法加一个锁。而如果该关键字修饰的方法是 static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。 但是抽象类不能实例化对象,因为该方法不是在该抽象类中实现的。是在其子类实现的。所以，锁应该归其子类所有。所以，抽象方法也就不能用 synchronized关键字修饰了;</li><li>native native这个东西本身就和 abstract冲突,他们都是方法的声明,只是一个把方法实现移交给子类,另一个是移交给本地操作系统。如果同时出现,就相当于即把实现移交给子类,又把实现移交给本地操作系统,那到底谁来实现具体方法呢</li></ol><p>接口是一种特殊的抽象类,接口中的方法全部是抽象方法(但其前的 abstract可以省略),所以抽象类中的抽象方法不能用的访间修饰符这里也不能用。</p><blockquote><p>接口protected访同修饰符也不能使用,因为接口可以让所有的类去实现(非继承),不只是其子类</p></blockquote><p>Jdk1.8</p><p>接口中可以有default类型的方法，实现类可以选择实现该方法</p><p>意义：默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。</p>',13),o=[c];function s(n,p){return l(),t("div",null,o)}const _=i(a,[["render",s],["__file","抽象类和接口.html.vue"]]);export{_ as default};
