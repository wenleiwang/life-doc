import{_ as d,r as n,o as r,c as h,b as a,e as i,w as t,d as e,a as o}from"./app-7rGY8hGP.js";const s="/life-doc/assets/4987cf1fe32873adc464fb897faacc9d-y5-H7w8m.png",c={},u=a("h1",{id:"虚拟机类的加载机制",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#虚拟机类的加载机制","aria-hidden":"true"},"#"),e(" 虚拟机类的加载机制")],-1),p={class:"table-of-contents"},f=o('<h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><p>在Java里，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p><p>这种策略荣Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销。</p><p>但却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h2 id="类加载的时机" tabindex="-1"><a class="header-anchor" href="#类加载的时机" aria-hidden="true">#</a> 类加载的时机</h2><p>一个类型从加载到虚拟机内存中开始，到卸载出内存位置，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个部分统称为连接。</p><p><img src="'+s+'" alt=""></p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班的开始。</p><p>解析阶段不一定：它在某些情况下可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p><blockquote><p>这里是按部就班的“开始”，而不是按部就班的“进行”或按部就班的“完成”。因为这些阶段通常都是相互交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p></blockquote><h3 id="有且只有六种情况必须立即对类进行初始化" tabindex="-1"><a class="header-anchor" href="#有且只有六种情况必须立即对类进行初始化" aria-hidden="true">#</a> 有且只有六种情况必须立即对类进行初始化</h3><ol><li>遇到new、getstatic、putstatic、或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条执行的典型Java代码场景： <ul><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li><li>调用一个类型的静态方法的时候</li></ul></li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li><li>当初始化类的时候，如果发现其父类还没有进行初始化，这需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类 （包含main方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用JDK7新加入的动态语言支持时，如果java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那么该接口要在其之前被初始化。</li></ol><h3 id="被动引用" tabindex="-1"><a class="header-anchor" href="#被动引用" aria-hidden="true">#</a> 被动引用</h3><p>除了这六种场景中的行为以外所有的引用类型的方式都不会触发初始化，称为被动引用。</p><ol><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li></ol><h2 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程" aria-hidden="true">#</a> 类加载过程</h2><h3 id="加载" tabindex="-1"><a class="header-anchor" href="#加载" aria-hidden="true">#</a> 加载</h3><p>在加载过程中完成3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><h3 id="验证" tabindex="-1"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h3><p>验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配 但必须注意到方法区本身是一个逻辑上的区域，在JDK1.7之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而JDK7及之后，类变量则会随着Class对象一起存放在Java堆中，这时“变量在方法区”就完全是一种逻辑概念的表达了。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h3><p>类的初始化阶段是类加载器的最后一个步骤，之前几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全有Java虚拟机来主导控制。 直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>准备阶段变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主管计划去初始化类变量和其他资源。</p><h2 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器" aria-hidden="true">#</a> 类加载器</h2><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”，这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。</p><p>实现这个动作的代码被称为“类加载器”</p><h3 id="类与类加载器" tabindex="-1"><a class="header-anchor" href="#类与类加载器" aria-hidden="true">#</a> 类与类加载器</h3><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类名称空间。</p><p>同一个Class文件，不同加载器加载，做对象所属类型检查时会返回false</p><blockquote><p>文章参考：</p><p>深入理解Java虚拟机第三版</p></blockquote>',37);function _(v,J){const l=n("router-link");return r(),h("div",null,[u,a("nav",p,[a("ul",null,[a("li",null,[i(l,{to:"#定义"},{default:t(()=>[e("定义")]),_:1})]),a("li",null,[i(l,{to:"#类加载的时机"},{default:t(()=>[e("类加载的时机")]),_:1}),a("ul",null,[a("li",null,[i(l,{to:"#有且只有六种情况必须立即对类进行初始化"},{default:t(()=>[e("有且只有六种情况必须立即对类进行初始化")]),_:1})]),a("li",null,[i(l,{to:"#被动引用"},{default:t(()=>[e("被动引用")]),_:1})])])]),a("li",null,[i(l,{to:"#类加载过程"},{default:t(()=>[e("类加载过程")]),_:1}),a("ul",null,[a("li",null,[i(l,{to:"#加载"},{default:t(()=>[e("加载")]),_:1})]),a("li",null,[i(l,{to:"#验证"},{default:t(()=>[e("验证")]),_:1})]),a("li",null,[i(l,{to:"#准备"},{default:t(()=>[e("准备")]),_:1})]),a("li",null,[i(l,{to:"#解析"},{default:t(()=>[e("解析")]),_:1})]),a("li",null,[i(l,{to:"#初始化"},{default:t(()=>[e("初始化")]),_:1})])])]),a("li",null,[i(l,{to:"#类加载器"},{default:t(()=>[e("类加载器")]),_:1}),a("ul",null,[a("li",null,[i(l,{to:"#类与类加载器"},{default:t(()=>[e("类与类加载器")]),_:1})])])])])]),f])}const x=d(c,[["render",_],["__file","class.html.vue"]]);export{x as default};
