import{_ as a,o as n,c as s,a as e}from"./app-7rGY8hGP.js";const t="/life-doc/assets/img_20231225_1-FwdljfKt.png",i="/life-doc/assets/img_20231225_2-cpiIrU_H.png",l={},p=e('<h1 id="jni技术" tabindex="-1"><a class="header-anchor" href="#jni技术" aria-hidden="true">#</a> JNI技术</h1><h2 id="_1-介绍" tabindex="-1"><a class="header-anchor" href="#_1-介绍" aria-hidden="true">#</a> 1. 介绍</h2><p>JNI（Java Native Interface，Java本地接口）是Java平台中的一个强大特性。应用程序可以通过JNI把C/C++代码集成进Java程序中。</p><p>通过JNI，开发者在利用Java平台强大功能的同时，又不必放弃对原有代码的投资；因为JNI是Java平台定义的规范接口，当程序员向Java代码集成本地库时，只要在一个平台中解决了语言互操作问题，就可以把该解决方案比较容易的移植到其他Java平台中。</p><h3 id="_1-1-java平台和主机环境" tabindex="-1"><a class="header-anchor" href="#_1-1-java平台和主机环境" aria-hidden="true">#</a> 1.1. Java平台和主机环境</h3><p>Java平台(Java Platform)的组成：Java VM和Java API。Java应用程序使用Java语言开发，然后编译成与平台无关的字节码(.class文件)。Java API由一组预定义的类组成。任何组织实现的Java平台都要支持：Java编程语言，虚拟机，和API。</p><p>平台环境: 操作系统，一组本机库，和CPU指令集。本地应用程序，通常依赖于一个特定的平台环境，用 C、C++等语言开发，并被编译成平台相关的二进制指令，目标二进制代码在不同OS间一般不具有可移植性。</p><p>Java平台(Java VM和Java API)一般在某个平台下开发。比如，Sun 的Java Runtime Environment(JRE)支持类Unix和Windows平台。Java平台做的所有努力，都为了使程序更具可移植性。</p><h3 id="_1-2-jni的角色" tabindex="-1"><a class="header-anchor" href="#_1-2-jni的角色" aria-hidden="true">#</a> 1.2. JNI的角色</h3><p>当Java平台部署到本地系统中，有必要做到让Java程序与本地代码协同工作。 部分是由于遗留代码(保护原有的投资)的问题(一些效率敏感的代码用C实现，但现在Java VM的执行效率完全可信赖)，工程师们很早就开始以C/C++为基础构建Java应用，所以，C/C++代码将长时间的与 Java 应用共存。JNI 让你在利用强大 Java 平台的同时，使你仍然可以用其他语言写程序。作为Java VM 的一部分，JNI是一套双向的接口，允许Java与本地代码间的互操作。</p><p><img src="'+t+'" alt=""></p><p>作为双向接口，JNI支持两种类型本地代码：本地库和本地应用。</p><ul><li>用本地代码实现Java中定义的native method接口，使Java调用本地代码；</li><li>通过JNI你可以把Java VM嵌到一个应用程序中，此时Java平台作为应用程序的增强，使其可以调用Java类库。</li></ul><p>JNI不只是一套接口，还是一套使用规则。Java语言有&quot;native&quot;关键字，声明哪些方法是用本地代码实现的。翻译的时候，对于&quot;native method&quot;，根据上下文意思做了不同处理，当native method指代Java中用&quot;native&quot;关键字修饰的那些方法时，不翻译；而当代码用C/C++实现的部分翻译成了本地代码。</p><p>在应用中嵌入Java VM的方法，是用最少的力量，为应用做最强扩展的不二选择，这时你的应用程序可以自由使用Java API的所有功能。</p><h3 id="_1-3-jni的影响" tabindex="-1"><a class="header-anchor" href="#_1-3-jni的影响" aria-hidden="true">#</a> 1.3. JNI的影响</h3><p>当Java程序集成了本地代码，它将丢掉Java的一些好处。</p><p>首先，脱离Java后，可移植性问题你要自己解决，且需重新在其他平台编译链接本地库。</p><p>第二，要小心处理JNI编程中各方面问题和来自C/C++语言本身的细节性问题，处理不当，应用将崩溃。</p><p>一般性原则：做好应用程序架构，使native methods定义在尽可能少的几个类里。</p><p><strong>优势和缺点</strong> 优点：</p><ul><li>方便地将 Java 类连接到本地代码，充分利用底层操作系统的功能；</li><li>支持编写高性能的本地代码，以提高某些关键任务的执行效率；</li><li>加强了跨平台开发的能力，可以充分利用本地特性，实现更复杂的功能需求。</li></ul><p>缺点：</p><ul><li>使用 JNI 需要额外的学习成本，包括 JNI 编程规范、内存管理等方面的知识；</li><li>开发人员需要维护 Java 类和本地代码之间的正确映射关系，增加了一定的复杂性。</li></ul><h3 id="_1-4-jni的使用场景" tabindex="-1"><a class="header-anchor" href="#_1-4-jni的使用场景" aria-hidden="true">#</a> 1.4. JNI的使用场景</h3><p>一典型的解决方案是，Java程序与本地代码分别运行在不同的进程中。采用进程分置最大的好处是：一个进程的崩溃，不会立即影响到另一个进程。</p><p>但是，把Java代码与本地代码置于一个进程有时是必要的。 如下：</p><ul><li>Java API可能不支某些平台相关的功能。比如，应用程序执行中要使用Java API不支持的文件类型，而如果使用跨进程操作方式，即繁琐又低效；</li><li>避免进程间低效的数据拷贝操作；</li><li>多进程的派生：耗时、耗资源(内存)；</li><li>用本地代码或汇编代码重写Java中低效方法。</li></ul><p>总之，如果Java必须与驻留同进程的本地代码交互，请使用JNI。</p><h2 id="_2-开始" tabindex="-1"><a class="header-anchor" href="#_2-开始" aria-hidden="true">#</a> 2. 开始</h2><p>本节用Hello World示例领略JNI编程。</p><h3 id="_2-1-总览" tabindex="-1"><a class="header-anchor" href="#_2-1-总览" aria-hidden="true">#</a> 2.1. 总览</h3><p>准备过程：</p><ol><li>创建一个类(HelloWorld.java)；</li><li>使用 javac 编译该类；</li><li>利用 javah -jni 产生头文件；</li><li>用本地代码实现头文件中定义的方法；</li><li>Run。</li></ol><p><img src="'+i+`" alt=""></p><h3 id="_2-2-声明本地方法" tabindex="-1"><a class="header-anchor" href="#_2-2-声明本地方法" aria-hidden="true">#</a> 2.2. 声明本地方法</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">new</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">static</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">&quot;HelloWorld&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HelloWrold类首先声明了一个private native print方法。static那几行是本地库。</p><p>在Java代码中声明本地方法必须有&quot;native&quot;标识符，native修饰的方法，在Java代码中只作为声明存在。</p><p>在调用本地方法前，必须首先装载含有该方法的本地库. 如HelloWorld.java中所示，置于static块中，在Java VM初始化一个类时，首先执行这部分代码，这可保证调用本地方法前，装载了本地库。</p><h3 id="_2-3-编译helloworld类" tabindex="-1"><a class="header-anchor" href="#_2-3-编译helloworld类" aria-hidden="true">#</a> 2.3. 编译HelloWorld类</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>javac HelloWorld.java
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2-4-创建本地方法头文件" tabindex="-1"><a class="header-anchor" href="#_2-4-创建本地方法头文件" aria-hidden="true">#</a> 2.4. 创建本地方法头文件</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>javah -jni HelloWorld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述命令，生成HelloWorld.h文件，关键部分如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_HelloWorld_print</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，请先忽略两个宏：JNIEXPORT和JNICALL。你会发现，该函数声明，接受两个参数，而对应的Java代码对该函数的声明没有参数。第一个参数是指向JNIEnv结构的指针；第二个参数，为HelloWorld对象自身，即this指针。</p><div class="custom-container tip"><p class="custom-container-title">这里有个坑</p><p>如果在项目里写会带着包名，例如：<code>package learn.note.jni</code> 使用上述命令会找不到类名，所以需要使用全限定名称 <code>package learn.note.jni.JNIUse1</code></p><p>还需要指定项目的路径使用 <code>-classpath</code></p><p>最终命令是<code>javah -classpath D:\\life\\life-learn\\src\\main\\java\\ -jni learn.note.jni.JNIUse1</code></p></div><hr><blockquote><p>https://zhuanlan.zhihu.com/p/650000825</p></blockquote>`,50),o=[p];function c(d,r){return n(),s("div",null,o)}const v=a(l,[["render",c],["__file","JNI技术.html.vue"]]);export{v as default};
