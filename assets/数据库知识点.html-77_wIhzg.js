import{_ as r,r as t,o as n,c as h,b as l,e as i,w as d,d as e,a as s}from"./app-7rGY8hGP.js";const o={},u=l("h1",{id:"数据库知识点",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#数据库知识点","aria-hidden":"true"},"#"),e(" 数据库知识点")],-1),c={class:"table-of-contents"},y=s(`<h2 id="数据库三范式" tabindex="-1"><a class="header-anchor" href="#数据库三范式" aria-hidden="true">#</a> 数据库三范式</h2><p>第一范式：确保每列的原子性，每列都是不可分割的最小数据单元 第二范式：在第一范式的基础上，要求每列都和主键相关 第三范式：在第二范式的基础上，要求其他列和主键是直接相关的，而不是间接相关的。</p><h2 id="分别说一下范式和反范式的优缺点" tabindex="-1"><a class="header-anchor" href="#分别说一下范式和反范式的优缺点" aria-hidden="true">#</a> 分别说一下范式和反范式的优缺点</h2><ol><li>范式化 优点： <ul><li>减少数据冗余</li><li>表中重复数据较少，更新操作比较快</li><li>范式化的表通常比反范式化的表小 缺点：</li><li>在查询的时候通常需要很多的关联，降低性能</li><li>增加了索引优化的难度</li></ul></li><li>反范式化 优点： <ul><li>可以减少表的关联</li><li>更好的进行索引优化 缺点：</li><li>数据重复冗余</li><li>对数据表的修改需要更多的成本</li></ul></li></ol><h2 id="mysql-数据库索引。b-树和-b-树的区别" tabindex="-1"><a class="header-anchor" href="#mysql-数据库索引。b-树和-b-树的区别" aria-hidden="true">#</a> Mysql 数据库索引。B+ 树和 B 树的区别</h2><p>MySQL数据库的索引和存储引擎有关。MyISAM和InnoDB只支出B数索引，MEMORY和HEAP支持Hash和B树索引。 B+树和B数的区别</p><ul><li>B+树非叶子节点只存储关键字和指向子节点的指针，而B树还存储了数据，在同样大小的情况下，B+树可以存储更多的关键字</li><li>B+树叶子节点存储了所有关键字和数据，并且多个节点用链表连接。可以快速支撑范围查找</li><li>B+树非叶子节点不存储数据，所以查询时间复杂度固定为O(logN)，B树查询的时间复杂度不固定，最好是O(1)</li></ul><h2 id="为什么-b-树比-b-树更适合应用于数据库索引-除了数据库索引-还有什么地方用到了-操作系统的文件索引" tabindex="-1"><a class="header-anchor" href="#为什么-b-树比-b-树更适合应用于数据库索引-除了数据库索引-还有什么地方用到了-操作系统的文件索引" aria-hidden="true">#</a> 为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）</h2><p>因为B树叶子节点和非叶子节点都存储了数据，这样就导致了非叶子节点能保存的关键字和指针变少，如果要保存大量的数据，只能增加树的高度，导致IO操作变多，查询性能降低。 处理数据库索引，还有操作系统的文件索引用到了B树。</p><h2 id="聚簇索引和非聚簇索引" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引" aria-hidden="true">#</a> 聚簇索引和非聚簇索引</h2><ol><li>聚簇索引：又叫主键索引，每个表只有一个主键索引，叶子节点保存主键的值和数据</li><li>非聚簇索引：又叫辅助索引，叶子节点保存索引字段的值和主键的值</li></ol><h2 id="前缀索引和覆盖索引" tabindex="-1"><a class="header-anchor" href="#前缀索引和覆盖索引" aria-hidden="true">#</a> 前缀索引和覆盖索引</h2><ol><li><p>前缀索引：对于列的值较长，比如BLOB、TEXT、VARCHAR，就必须建立前缀索引，即将值的前一部分作为索引。这样既可以节约空间，又可以提高查询效率。 但无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做扫描覆盖。</p></li><li><p>覆盖索引：select的数据列从索引中就能获得，不必再从数据表中的读取。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫覆盖索引。 当发起一个被索引覆盖的查询（也叫索引覆盖查询）时，在<code>EXPLAIN</code>的<code>Extra</code>列可以看到<code>Using index</code>的信息</p></li></ol><h2 id="介绍一下数据库的事务" tabindex="-1"><a class="header-anchor" href="#介绍一下数据库的事务" aria-hidden="true">#</a> 介绍一下数据库的事务</h2><p>事务是一个操作序列，这些操作要么全部执行，要么不执行。 事务具有四大特性：</p><ul><li>原子性（A）</li><li>一致性（C）</li><li>隔离性（I）</li><li>持久性（D）</li></ul><h2 id="mysql-有哪些隔离级别" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些隔离级别" aria-hidden="true">#</a> Mysql 有哪些隔离级别</h2><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="mysql-什么情况会造成脏读、不可重复度、幻读-如何解决" tabindex="-1"><a class="header-anchor" href="#mysql-什么情况会造成脏读、不可重复度、幻读-如何解决" aria-hidden="true">#</a> Mysql 什么情况会造成脏读、不可重复度、幻读？如何解决</h2><ol><li>脏读：有两个事务A和B，A读取已经B修改但未提交的字段，此时B回滚，那么A读取的字段就是临时且无效的。可以提交隔离级别，改成读已提交</li><li>不可重复读：有两个事务A和B，A读取了一个字段值，然后B更新并提交事务，A再重新读取这个字段，就和之前不相等了。可以提高隔离级别</li><li>幻读：有两个事务A和B，A读取了某个范围内的记录时，B又在该范围内插入了新的提交记录并提交，当事务A再次读取该范围的记录时，会产生幻行。 可以升级隔离级别到串行化，或者使用MVCC + next-key 锁机制实现</li></ol><h2 id="mysql-在可重复读的隔离级别下会不会有幻读的情况-为什么" tabindex="-1"><a class="header-anchor" href="#mysql-在可重复读的隔离级别下会不会有幻读的情况-为什么" aria-hidden="true">#</a> Mysql 在可重复读的隔离级别下会不会有幻读的情况，为什么？</h2><p>不会。InnoDB存储引擎默认隔离级别为RR，通过MVCC + next-key锁机制解决了幻读的问题。 PS：其实严格来说，是存在幻读的。。。可以尝试一下这个操作，A开启事务，执行查询，此时B开启事务新增一条数据并提交，此时A再查询，发现没有幻读，但是如果A执行一个update操作，再查询，会发现出现了幻读。我认为应该是A在执行update操作的时候，新建了一条创建版本号为A事务版本号的记录，然后标记B事务创建的记录为待删除的，查询的版本号依据是删除版本号为空或大于当前版本号，并且创建版本号小于等于当前事务版本号，那么这里刚刚A更新的这条数据，显然也符合查询的条件，所以也会被查出来。</p><p>MVCC版本号原理参考文章：Mysql中MVCC的使用及原理详解</p><p>详细测试参考文章：MySQL可重复读级别会不会造成幻读</p><h2 id="mysql-事务是如何实现的" tabindex="-1"><a class="header-anchor" href="#mysql-事务是如何实现的" aria-hidden="true">#</a> Mysql 事务是如何实现的</h2><ul><li>原子性：通过 <code>undo log</code>实现。每条数据变更都伴随一条<code>undo log</code>日志的生成，当系统发生错误或执行回滚根据<code>undo log</code>做逆向操作</li><li>持久性：通过<code>redo log</code>实现。<code>redo log</code>记录了数据的修改日志。数据持久化到磁盘，先是存储到缓存池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取<code>redo log</code>恢复数据</li><li>隔离性：MySQL数据库通过MVCC + next-key机制实现了隔离性</li><li>一致性：以上3大特性，保障了事务的一致性</li></ul><h2 id="binlog-和-redo-log-的区别是什么-分别是什么用" tabindex="-1"><a class="header-anchor" href="#binlog-和-redo-log-的区别是什么-分别是什么用" aria-hidden="true">#</a> Binlog 和 Redo log 的区别是什么，分别是什么用？</h2><ul><li>Binlog是二进制文件，记录了数据库执行更改的所有操作，不包括select、show，因为这两个操作没有对数据本身做修改。但若操作了数据，但是数据没有发生变化，也会记录到binlog。常用来恢复数据，数据备份。</li><li>redo log又叫做从做日志文件，记录了事务的修改，不管事务是否提交都记录下来。在实例和介质失败时，InnoDB存储引擎会使用redo log恢复到之前的状态，保证数据的完整性。</li></ul><h2 id="谈一谈-mvcc-多版本并发控制" tabindex="-1"><a class="header-anchor" href="#谈一谈-mvcc-多版本并发控制" aria-hidden="true">#</a> 谈一谈 MVCC 多版本并发控制</h2><p>MVCC是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来与查询到的每行记录的版本号进行比较。</p><ul><li>select 会根据以下两条检查每行记录： <ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。</li><li>行的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。 只有符合上述两个条件的记录，才能返回作为查询结果。</li></ul></li><li>inster InnoDB为新插入的每一行保存当前系统版本号作为行号</li><li>delete InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li><li>update InnoDB为插入一行新记录，保存当前系统版本号作为版本号，同时保存当前系统版号到原来的行为作为删除标识。</li></ul><h2 id="innodb-和-myisam-的区别是什么" tabindex="-1"><a class="header-anchor" href="#innodb-和-myisam-的区别是什么" aria-hidden="true">#</a> Innodb 和 MyISAM 的区别是什么</h2><h2 id="innodb-的默认加锁方式是什么-是怎么实现的" tabindex="-1"><a class="header-anchor" href="#innodb-的默认加锁方式是什么-是怎么实现的" aria-hidden="true">#</a> Innodb 的默认加锁方式是什么，是怎么实现的</h2><p>InnoDB默认加锁方式是行锁，通过给索引上的索引项加锁来实现的</p><h2 id="mysql-索引重建" tabindex="-1"><a class="header-anchor" href="#mysql-索引重建" aria-hidden="true">#</a> Mysql 索引重建</h2><h2 id="对于多列索引-哪些情况下能用到索引-哪些情况用不到索引" tabindex="-1"><a class="header-anchor" href="#对于多列索引-哪些情况下能用到索引-哪些情况用不到索引" aria-hidden="true">#</a> 对于多列索引，哪些情况下能用到索引，哪些情况用不到索引</h2><ul><li>like以%开头</li><li>or查询，必须左右字段都是索引，否则索引失效</li><li>联合索引，遵从最左匹配原则，如果不是使用第一列索引，索引失效</li><li>数据出现隐形转换，如varchar字段没加单引号，自动转为int类型，会使索引失效</li><li>索引字段使用not、&lt;&gt;、!=，索引失效</li><li>索引字段使用函数，索引无效</li></ul><h2 id="为什么使用数据库索引可以提高效率-在什么情况下会用不到数据库索引" tabindex="-1"><a class="header-anchor" href="#为什么使用数据库索引可以提高效率-在什么情况下会用不到数据库索引" aria-hidden="true">#</a> 为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？</h2><p>默认执行SQL语句是进行全表扫描，遇到匹配条件的就加入搜索结果合集。如果有索引，就会先去索引表中一次定位到特定值的行数，减少遍历匹配的行数。索引把无序的数据变成了相对有序的数据结构。</p><h2 id="共享锁和排他锁的使用场景" tabindex="-1"><a class="header-anchor" href="#共享锁和排他锁的使用场景" aria-hidden="true">#</a> 共享锁和排他锁的使用场景</h2><h2 id="关系型数据库和非关系数据库的优缺点" tabindex="-1"><a class="header-anchor" href="#关系型数据库和非关系数据库的优缺点" aria-hidden="true">#</a> 关系型数据库和非关系数据库的优缺点</h2><p>关系型数据库 优点：</p><ul><li>二维表格，容易理解</li><li>操作方便</li><li>易于维护</li><li>支持SQL 缺点：</li><li>读写性能较差</li><li>固定的表结构，不够灵活</li><li>应对高并发场景，磁盘I/O存在瓶颈</li><li>海量数据的读写性能差 非关系型数据库 优点：</li><li>不需要SQL解析，读写性能高</li><li>可以使用硬盘或者内存作为载体，速度快</li><li>基于键值对，数据没有耦合性，方便扩展</li><li>部署简单 缺点：</li><li>不支持SQL，增加了学习成本</li><li>没有事务</li></ul><h2 id="mysql-什么情况会造成慢查-如何查看慢查询" tabindex="-1"><a class="header-anchor" href="#mysql-什么情况会造成慢查-如何查看慢查询" aria-hidden="true">#</a> Mysql 什么情况会造成慢查，如何查看慢查询</h2><h2 id="如何处理慢查询-你一般是怎么处理慢查询的" tabindex="-1"><a class="header-anchor" href="#如何处理慢查询-你一般是怎么处理慢查询的" aria-hidden="true">#</a> 如何处理慢查询，你一般是怎么处理慢查询的</h2><ol><li>把数据、日志、索引放到不同的I/O设备上，增加读取速度</li><li>纵向、横向分割表，减少表的尺寸</li><li>升级硬件</li><li>根据查询条件，建立索引，索引优化</li><li>提高网速</li><li>扩大服务器内存</li><li>分库分表</li></ol><h2 id="mysql-中-varchar-和-char-的区别" tabindex="-1"><a class="header-anchor" href="#mysql-中-varchar-和-char-的区别" aria-hidden="true">#</a> Mysql 中 varchar 和 char 的区别</h2><p>varchar会根据存储的内容改变长度，char是定长，如果长度不够，则使用空格补齐</p><h2 id="数据库外键的优缺点" tabindex="-1"><a class="header-anchor" href="#数据库外键的优缺点" aria-hidden="true">#</a> 数据库外键的优缺点</h2><p>优点：</p><ul><li><p>能最大限度的保证数据的一致性和完整性</p></li><li><p>增加ER图的可读性 缺点：</p></li><li><p>影响数据操作的效率</p></li><li><p>增加开发难度，导致表过多</p></li></ul><h2 id="有没有使用过数据库的视图" tabindex="-1"><a class="header-anchor" href="#有没有使用过数据库的视图" aria-hidden="true">#</a> 有没有使用过数据库的视图</h2><p>使用create view view_name as select * from tb创建视图</p><p>使用select * from view_name正常查询视图</p><h2 id="mysql-中插入数据使用自增-id-好还是使用-uuid-为什么" tabindex="-1"><a class="header-anchor" href="#mysql-中插入数据使用自增-id-好还是使用-uuid-为什么" aria-hidden="true">#</a> Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？</h2><p>单实例或单节点组，不担心网络爬虫获取数据量，推荐使用自增id，性能更好 分布式场景。20个节点下的小规模分布式场景，推荐uuid。20~200个节点的中规模分布式场景，推荐自增id+步长的策略。200以上节点，推荐推特雪花算法的全局自增ID</p><p>#UUID #唯一标识</p><h2 id="mysql-有哪些数据类型-使用的时候有没有什么注意点" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些数据类型-使用的时候有没有什么注意点" aria-hidden="true">#</a> Mysql 有哪些数据类型，使用的时候有没有什么注意点</h2><ul><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TIMESTAMP、TIME、YEAR</li></ul><p>使用的时候建议遵循从小原则。</p><ul><li>使用char和vahrchar的时候，注意char会去掉字符串末尾的空格</li><li>使用text和blob的时候，注意定期清理碎片空间，使用OPTIMIZE TABLE命令</li><li>浮点数会造成精度丢失，尽量使用定点数DECIMAL</li></ul><h2 id="mysql-集群有哪几种方式-分别适用于什么场景" tabindex="-1"><a class="header-anchor" href="#mysql-集群有哪几种方式-分别适用于什么场景" aria-hidden="true">#</a> Mysql 集群有哪几种方式，分别适用于什么场景</h2><p>组建MySQL集群的方式：</p><p>LVS + Keepalived + MySQL DRBD + Heartbeat + MySQL MySQL + Proxy MySQL Cluster MySQL + MHA MySQL + MMM 场景：</p><p>如果是双主复制，不需要数据拆分，可以使用MHA或Keepalived或Heartbeat 如果是双主复制，需要数据拆分，采用Cobar</p><h2 id="mysql-主从模式如何保证主从强一致性" tabindex="-1"><a class="header-anchor" href="#mysql-主从模式如何保证主从强一致性" aria-hidden="true">#</a> Mysql 主从模式如何保证主从强一致性</h2><p>主从复制原理：master写数据留下写入日志，slave根据master留下的日志模仿数据执行过程写入</p><p>所以有两个步骤可能导致主从复制不一致：</p><p>master日志写入不成功 slave根据日志模仿不成功</p><p>解决办法：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>innodb_flush_log_at_trx_commit = 1
sync_binlog = 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>保证每次事务提交后，都能实时刷新到磁盘中，尤其是确保每次事务对应的binlog都能及时刷新到磁盘中</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code>master_info_repository = &quot;TABLE&quot;
relay_log_info_repository = &quot;TABLE&quot;
relay_log_recovery = 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>确保在slave上和复制相关的元数据表也采用InnoDB引擎，受到InnoDB事务安全的保护，而后一个选项的作用是开启relay log自动修复机制，发生crash时，会自动判断哪些relay log需要重新从master上抓取回来再次应用，以此避免部分数据丢失的可能性。</p><h2 id="mysql-集群如何保证主从可用性" tabindex="-1"><a class="header-anchor" href="#mysql-集群如何保证主从可用性" aria-hidden="true">#</a> Mysql 集群如何保证主从可用性</h2><p>使用HA检测工具。HA工具部署在第三台服务器上，同时连接主从，检测主从是否存活。如果主库宕机则及时将从库升级为主库，将原来的主库降级为从库</p><h2 id="mysql-读写分离有哪些解决办法" tabindex="-1"><a class="header-anchor" href="#mysql-读写分离有哪些解决办法" aria-hidden="true">#</a> Mysql 读写分离有哪些解决办法</h2><p>配置多数据源 使用中间件代理</p>`,78);function m(p,b){const a=t("router-link");return n(),h("div",null,[u,l("nav",c,[l("ul",null,[l("li",null,[i(a,{to:"#数据库三范式"},{default:d(()=>[e("数据库三范式")]),_:1})]),l("li",null,[i(a,{to:"#分别说一下范式和反范式的优缺点"},{default:d(()=>[e("分别说一下范式和反范式的优缺点")]),_:1})]),l("li",null,[i(a,{to:"#mysql-数据库索引。b-树和-b-树的区别"},{default:d(()=>[e("Mysql 数据库索引。B+ 树和 B 树的区别")]),_:1})]),l("li",null,[i(a,{to:"#为什么-b-树比-b-树更适合应用于数据库索引-除了数据库索引-还有什么地方用到了-操作系统的文件索引"},{default:d(()=>[e("为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）")]),_:1})]),l("li",null,[i(a,{to:"#聚簇索引和非聚簇索引"},{default:d(()=>[e("聚簇索引和非聚簇索引")]),_:1})]),l("li",null,[i(a,{to:"#前缀索引和覆盖索引"},{default:d(()=>[e("前缀索引和覆盖索引")]),_:1})]),l("li",null,[i(a,{to:"#介绍一下数据库的事务"},{default:d(()=>[e("介绍一下数据库的事务")]),_:1})]),l("li",null,[i(a,{to:"#mysql-有哪些隔离级别"},{default:d(()=>[e("Mysql 有哪些隔离级别")]),_:1})]),l("li",null,[i(a,{to:"#mysql-什么情况会造成脏读、不可重复度、幻读-如何解决"},{default:d(()=>[e("Mysql 什么情况会造成脏读、不可重复度、幻读？如何解决")]),_:1})]),l("li",null,[i(a,{to:"#mysql-在可重复读的隔离级别下会不会有幻读的情况-为什么"},{default:d(()=>[e("Mysql 在可重复读的隔离级别下会不会有幻读的情况，为什么？")]),_:1})]),l("li",null,[i(a,{to:"#mysql-事务是如何实现的"},{default:d(()=>[e("Mysql 事务是如何实现的")]),_:1})]),l("li",null,[i(a,{to:"#binlog-和-redo-log-的区别是什么-分别是什么用"},{default:d(()=>[e("Binlog 和 Redo log 的区别是什么，分别是什么用？")]),_:1})]),l("li",null,[i(a,{to:"#谈一谈-mvcc-多版本并发控制"},{default:d(()=>[e("谈一谈 MVCC 多版本并发控制")]),_:1})]),l("li",null,[i(a,{to:"#innodb-和-myisam-的区别是什么"},{default:d(()=>[e("Innodb 和 MyISAM 的区别是什么")]),_:1})]),l("li",null,[i(a,{to:"#innodb-的默认加锁方式是什么-是怎么实现的"},{default:d(()=>[e("Innodb 的默认加锁方式是什么，是怎么实现的")]),_:1})]),l("li",null,[i(a,{to:"#mysql-索引重建"},{default:d(()=>[e("Mysql 索引重建")]),_:1})]),l("li",null,[i(a,{to:"#对于多列索引-哪些情况下能用到索引-哪些情况用不到索引"},{default:d(()=>[e("对于多列索引，哪些情况下能用到索引，哪些情况用不到索引")]),_:1})]),l("li",null,[i(a,{to:"#为什么使用数据库索引可以提高效率-在什么情况下会用不到数据库索引"},{default:d(()=>[e("为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？")]),_:1})]),l("li",null,[i(a,{to:"#共享锁和排他锁的使用场景"},{default:d(()=>[e("共享锁和排他锁的使用场景")]),_:1})]),l("li",null,[i(a,{to:"#关系型数据库和非关系数据库的优缺点"},{default:d(()=>[e("关系型数据库和非关系数据库的优缺点")]),_:1})]),l("li",null,[i(a,{to:"#mysql-什么情况会造成慢查-如何查看慢查询"},{default:d(()=>[e("Mysql 什么情况会造成慢查，如何查看慢查询")]),_:1})]),l("li",null,[i(a,{to:"#如何处理慢查询-你一般是怎么处理慢查询的"},{default:d(()=>[e("如何处理慢查询，你一般是怎么处理慢查询的")]),_:1})]),l("li",null,[i(a,{to:"#mysql-中-varchar-和-char-的区别"},{default:d(()=>[e("Mysql 中 varchar 和 char 的区别")]),_:1})]),l("li",null,[i(a,{to:"#数据库外键的优缺点"},{default:d(()=>[e("数据库外键的优缺点")]),_:1})]),l("li",null,[i(a,{to:"#有没有使用过数据库的视图"},{default:d(()=>[e("有没有使用过数据库的视图")]),_:1})]),l("li",null,[i(a,{to:"#mysql-中插入数据使用自增-id-好还是使用-uuid-为什么"},{default:d(()=>[e("Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？")]),_:1})]),l("li",null,[i(a,{to:"#mysql-有哪些数据类型-使用的时候有没有什么注意点"},{default:d(()=>[e("Mysql 有哪些数据类型，使用的时候有没有什么注意点")]),_:1})]),l("li",null,[i(a,{to:"#mysql-集群有哪几种方式-分别适用于什么场景"},{default:d(()=>[e("Mysql 集群有哪几种方式，分别适用于什么场景")]),_:1})]),l("li",null,[i(a,{to:"#mysql-主从模式如何保证主从强一致性"},{default:d(()=>[e("Mysql 主从模式如何保证主从强一致性")]),_:1})]),l("li",null,[i(a,{to:"#mysql-集群如何保证主从可用性"},{default:d(()=>[e("Mysql 集群如何保证主从可用性")]),_:1})]),l("li",null,[i(a,{to:"#mysql-读写分离有哪些解决办法"},{default:d(()=>[e("Mysql 读写分离有哪些解决办法")]),_:1})])])]),y])}const q=r(o,[["render",m],["__file","数据库知识点.html.vue"]]);export{q as default};
