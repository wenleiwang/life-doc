import{_ as o,r as t,o as l,c as p,b as n,d as a,e as i,a as s}from"./app-7rGY8hGP.js";const r="/life-doc/assets/eb25942781fb775548cdcadea97ad6cd-JtOXbeFQ.png",c="/life-doc/assets/77f69c4460d3f0616ed4e3d8689ff62d-28-IKZEu.png",d="/life-doc/assets/29d6d02fb76ae2692ec0b6e143382cf5-ipNjf-Ga.png",v="/life-doc/assets/f888ef70590e1715212967fd1739d481-1KXPiujH.png",u={},k=s('<h1 id="volatile" tabindex="-1"><a class="header-anchor" href="#volatile" aria-hidden="true">#</a> volatile</h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介" aria-hidden="true">#</a> 1.简介</h2><p>volatile就可以说是java虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用synchronized。Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。</p><p>现在我们有了一个大概的印象就是：<strong>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</strong></p><h2 id="_2-volatile实现原理" tabindex="-1"><a class="header-anchor" href="#_2-volatile实现原理" aria-hidden="true">#</a> 2.volatile实现原理</h2><p>在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令</strong>（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个<strong>Lock</strong>指令肯定有神奇的地方，那么Lock前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：</p><ol><li>将当前处理器缓存行的数据写回系统内存；</li><li>这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效</li></ol><p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性</strong>协议，<strong>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期</strong>了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：</p><ol><li>Lock前缀的指令会引起处理器缓存写回内存；</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效；</li><li>当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</li></ol><p>这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p><h2 id="_3-volatile的happens-before关系" tabindex="-1"><a class="header-anchor" href="#_3-volatile的happens-before关系" aria-hidden="true">#</a> 3.volatile的happens-before关系</h2><p>经过上面的分析，我们已经知道了volatile变量可以通过<strong>缓存一致性协议</strong>保证每个线程都能获得最新值，即满足数据的“可见性”。我们继续延续上一篇分析问题的方式（我一直认为思考问题的方式是属于自己，也才是最重要的，也在不断培养这方面的能力），我一直将并发分析的切入点分为<strong>两个核心，三大性质</strong>。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性（关于三大性质的总结在以后得文章会和大家共同探讨）。废话不多说，先来看两个核心之一：volatile的happens-before关系。</p>',12),h={href:"https://www.jianshu.com/p/d52fea0d6ba5",target:"_blank",rel:"noopener noreferrer"},f=s(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">//1</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">//2</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//3</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">//4</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的实例代码对应的happens-before关系如下图所示： <img src="`+r+'" alt=""></p><p>加锁线程A先执行writer方法，然后线程B执行reader方法图中每一个箭头两个节点就代码一个happens-before关系，黑色的代表根据<strong>程序顺序规则</strong>推导出来，红色的是根据<strong>volatile变量的写happens-before 于任意后续对volatile变量的读</strong>，而蓝色的就是根据传递性规则推导出来的。这里的2 happen-before 3，同样根据happens-before规则定义：如果A happens-before B,则A的执行结果对B可见，并且A的执行顺序先于B的执行顺序，我们可以知道操作2执行结果对操作3来说是可见的，也就是说当线程A将volatile变量 flag更改为true后线程B就能够迅速感知。</p><h2 id="_4-volatile的内存语义" tabindex="-1"><a class="header-anchor" href="#_4-volatile的内存语义" aria-hidden="true">#</a> 4.volatile的内存语义</h2><p>还是按照<strong>两个核心</strong>的分析方式，分析完happens-before关系后我们现在就来进一步分析volatile的内存语义（按照这种方式去学习，会不会让大家对知识能够把握的更深，而不至于不知所措，如果大家认同我的这种方式，不妨给个赞，小弟在此谢过，对我是个鼓励）。还是以上面的代码为例，假设线程A先执行writer方法，线程B随后执行reader方法，初始时线程的本地内存中flag和a都是初始状态，下图是线程A执行volatile写后的状态图 <img src="'+c+'" alt=""> 当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程B再需要读取从主内存中去读取该变量的最新值。下图就展示了线程B读取同一个volatile变量的内存变化示意图。 <img src="'+d+'" alt=""> 从横向来看，线程A和线程B之间进行了一次通信，线程A在写volatile变量时，实际上就像是给B发送了一个消息告诉线程B你现在的值都是旧的了，然后线程B读这个volatile变量时就像是接收了线程A刚刚发送的消息。既然是旧的了，那线程B该怎么办了？自然而然就只能去主内存去取啦。</p><p>好的，我们现在<strong>两个核心</strong>：happens-before以及内存语义现在已经都了解清楚了。</p><h3 id="_4-1-volatile的内存语义的实现" tabindex="-1"><a class="header-anchor" href="#_4-1-volatile的内存语义的实现" aria-hidden="true">#</a> 4.1 volatile的内存语义的实现</h3><p>我们都知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。</p><p>JMM内存屏障分为四类见下图， <img src="'+v+'" alt=""></p><hr><p>#线程</p>',11);function b(m,_){const e=t("ExternalLinkIcon");return l(),p("div",null,[k,n("p",null,[a("在六条"),n("a",h,[a("happens-before规则"),i(e)]),a("中有一条是：**volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。**下面我们结合具体的代码，我们利用这条规则推导下：")]),f])}const w=o(u,[["render",b],["__file","关键字volatile.html.vue"]]);export{w as default};
