import{_ as o,r as p,o as c,c as l,b as n,e,w as t,d as a,a as i}from"./app-7rGY8hGP.js";const r="/life-doc/assets/39954f01ada66d0aa7664dde2ef4ca05-jXW7DY33.png",u={},d=n("h1",{id:"二叉树的镜像",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#二叉树的镜像","aria-hidden":"true"},"#"),a(" 二叉树的镜像")],-1),k={class:"table-of-contents"},m=i('<h2 id="_0-题目" tabindex="-1"><a class="header-anchor" href="#_0-题目" aria-hidden="true">#</a> 0.题目</h2><h2 id="_1-递归解法" tabindex="-1"><a class="header-anchor" href="#_1-递归解法" aria-hidden="true">#</a> 1.递归解法</h2><h3 id="_1-1思路" tabindex="-1"><a class="header-anchor" href="#_1-1思路" aria-hidden="true">#</a> 1.1思路</h3><p>根据后续遍历特性，得到如下推倒，看蓝色示意图是递归推导执行顺序。第三步交换时它的子结点都已经交换完成</p><p><img src="'+r+`" alt=""></p><h3 id="_1-2代码" tabindex="-1"><a class="header-anchor" href="#_1-2代码" aria-hidden="true">#</a> 1.2代码</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">learn<span class="token punctuation">.</span>note<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>binarytree</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bm33_Mirror</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">TreeNode</span> tree <span class="token operator">=</span> <span class="token class-name">CreateTree</span><span class="token punctuation">.</span><span class="token function">createTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> mirror <span class="token operator">=</span> <span class="token function">mirror</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">TreeNode</span> mirror <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> pRoot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 完成遍历</span>
        <span class="token function">mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">mirror</span><span class="token punctuation">(</span>pRoot<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 交换</span>
        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> pRoot<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        pRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> pRoot<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        pRoot<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>
        <span class="token keyword">return</span> pRoot<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-非递归解法" tabindex="-1"><a class="header-anchor" href="#_2-非递归解法" aria-hidden="true">#</a> 2.非递归解法</h2>`,8);function v(h,_){const s=p("router-link");return c(),l("div",null,[d,n("nav",k,[n("ul",null,[n("li",null,[e(s,{to:"#_0-题目"},{default:t(()=>[a("0.题目")]),_:1})]),n("li",null,[e(s,{to:"#_1-递归解法"},{default:t(()=>[a("1.递归解法")]),_:1}),n("ul",null,[n("li",null,[e(s,{to:"#_1-1思路"},{default:t(()=>[a("1.1思路")]),_:1})]),n("li",null,[e(s,{to:"#_1-2代码"},{default:t(()=>[a("1.2代码")]),_:1})])])]),n("li",null,[e(s,{to:"#_2-非递归解法"},{default:t(()=>[a("2.非递归解法")]),_:1})])])]),m])}const f=o(u,[["render",v],["__file","binarytree_mirror.html.vue"]]);export{f as default};
