# MySQL事务
## 什么是事务？
一组操作，要么都执行，要么都不执行。

经典例子：银行转账，A给B转账。要从A的账户扣除100元，在给B的账户增加100元。事务就是为了保证这个过程的顺利完成，
要么都成功要么都失败。

## 事务的特性（CAID）
### 原子性
事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
### 一致性
执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
### 隔离性
并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
### 持久性
一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 并发事务带来的问题
### 脏读（Dirty read）
一个事务对数据进行修改单位提交，这时另外一个事务也对这个数据进行读取，并使用了这个数据。因为这个数据是还没有提交的数据，
那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

### 丢失修改（Lost to modify）
指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。
这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 

例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。

### 不可重复读
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。
这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

### 幻读
幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。
在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

> 不可重复读和幻读的区别：
>
> 不可重复读的重点是修改，幻读的重点在于新增或者删除。

## 事务隔离级别
### 读未提交
最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
### 读已提交
允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
### 可重复读
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
### 可串行化
最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

> MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。
>

::: tip 注意
标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。但是InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。

* 快照读 ：由 MVCC 机制来保证不出现幻读。
* 当前读 ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。

InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。
:::

## 解决幻读的方法
解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：
1. 将事务隔离级别调整为 SERIALIZABLE
2. 在可重复读的事务级别下，给事务操作的这张表添加表锁
3. 在可重复读的事务级别下，给事务操作的这张表添加 Next-Key Locks


> 参考：
> 
> https://javaguide.cn/database/mysql/transaction-isolation-level.html#%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E6%BC%94%E7%A4%BA
> 
> 《MySQL 技术内幕：InnoDB 存储引擎》