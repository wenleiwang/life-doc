# 抽象类和接口
jdk1.8之前

抽象类
1. 单继承
2. 变量类型不限（静态变量+非静态变量）
3. 函数类型不限（静态函数+非静态函数）
4. 非静态函数包含没有方法体的抽象函数. 有方法体的普通函数
5. 子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法
6. 可以有main方法；不可以new一个抽象类
7. 可以有构造器

接口
1. 多实现
2. 变量类型默认且只能为为public static final
3. 函数类型默认且只能为public，只能有public类型的静态成员函数
4. 非静态成员函数没有方法体，静态成员函数有方法体
5. 子类必须实现所有接口函数
6. 可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数
7. 没有构造器

抽象类中的抽象方法(其前有 abstract1修饰)不能用 private、 static、 synchronized、native访回修饰符修饰。

1. private
抽象方法没有方法体,是用来被继承的,所以不能用 private修饰;
2.static
static修饰的方法可以通过类名来访间该方法(即该方法的方法体),抽象方法用sttic修饰没有意义;
3. synchronized
该关键字是为该方法加一个锁。而如果该关键字修饰的方法是 static方法。则使用的锁就是class变量的锁。如果是修饰类方法。则用this变量锁。
但是抽象类不能实例化对象,因为该方法不是在该抽象类中实现的。是在其子类实现的。所以，锁应该归其子类所有。所以，抽象方法也就不能用 synchronized关键字修饰了;
3. native
native这个东西本身就和 abstract冲突,他们都是方法的声明,只是一个把方法实现移交给子类,另一个是移交给本地操作系统。如果同时出现,就相当于即把实现移交给子类,又把实现移交给本地操作系统,那到底谁来实现具体方法呢

接口是一种特殊的抽象类,接口中的方法全部是抽象方法(但其前的 abstract可以省略),所以抽象类中的抽象方法不能用的访间修饰符这里也不能用。

> 接口protected访同修饰符也不能使用,因为接口可以让所有的类去实现(非继承),不只是其子类


Jdk1.8

接口中可以有default类型的方法，实现类可以选择实现该方法

意义：默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。