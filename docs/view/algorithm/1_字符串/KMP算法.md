# KMP算法

## 什么是KMP算法？

KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。

KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度 `O(m+n)`。

[文章讲的很详细](https://cloud.tencent.com/developer/article/2235837)

[这个原理用图示比较清晰](https://kb.cnblogs.com/page/176818/)
#### 字符串的前缀和后缀

首先我们需要知道字符串的前缀和后缀： 对于字符串`ababc`来说，它的前缀有`[a,ab,aba,abab]`，也就是以字符串第一个字符作为开头，同时不包括最后一个字符的所有子串，同理它的后缀有`[c,bc,abc,babc]`，也就是以字符串最后一个字符作为结尾，同时不包括第一个字符的所有字串。

#### 字符串的最长公共前后缀

了解了这个，我们再来说什么是字符串的**最长公共前后缀**，说白了，也就是前缀和后缀这2个集合中的相同部分，同时取最长的那个，就是这个字符串的**最长公共前后缀**。显然，在这个例子中，`ababc`是没有公共前后缀的。但是对于`abab`，它的前缀和后缀分别是`[a,ab,aba]`和`[b,ab,bab]`，那么它的**最长公共前后缀**就是`ab`。

现在，我们的目标就是取得`ababc`所有子串`[a,ab,aba,abab,ababc]`的**最长公共前后缀**的长度，分别保存在`next`数组中，我们只要知道最大长度即可，并不用关心串具体是什么，而我们目前通过观察即可得出next数组这里是`[0,0,1,2,0]`，我们先知道这个结果即可，此计算方法后续会说明。
## 实现一下

```java

```



![](https://cdn.jsdelivr.net/gh/wenleiwang/life-img/note-img/v2-988c7f256e91c00976cdfa463678790e_720w.webp)



