# 线程
[[toc]]

## 线程状态转换

![](img/thread/0d9f00e54c80fbfeadf30ce5bac7b7f5.png)

## 线程的创建
1. 继承Thread
2. 实现Runnable接口
3. 实现Callable接口

## 线程的生命周期
1. 新建状态(New)

创建一个线程对象后，该线程对象就处于新建状态，此时它不能运行，与其他Java对象一样，仅仅由Java虚拟机为其分配了内存，没有表现出任何线程的动态特征。

2. 就绪状态(Runnable)

当线程对象调用了start()方法后，该线程就进入就绪状态。处于就绪状态的线程位于线程队列中，此时它只是具备了运行的条件，能否获得CPU的使用权并开始运行，还需要等待系统的调度。

3. 运行状态(Running)

如果处于就绪状态的线程获得了CPU的使用权，并开始执行run()方法中的线程执行体，则该线程处于运行状态。一个线程启动后，它可能不会一直处于运行状态，当运行状态的线程使用完系统分配的时间后，系统就会剥夺该线程占用的CPU资源，让其他线程获得执行的机会。需要注意的是，只有处于就绪状态的线程才可能转换到运行状态。

4. 阻塞状态(Blocked)

一个正在执行的线程在某些特殊情况下，如被人为挂起或执行耗时的输入/输出操作时，会让出CPU的使用权并暂时中止自己的执行，进人阻塞状态。线程进人阻塞状态后，就不能进入排队队列。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。

下面就列举一下线程由运行状态转换成阻塞状态的原因，以及如何从阻塞状态转换成就绪状态。

* 当线程试图获取某个对象的同步锁时，如里该销被其他线程所持有，则当前线程会进入阻塞状态，如果想从阻塞状态进入就绪状态就必须获取到其他线程所持有的锁。

* 当线程调用了一个阻塞式的I/O方法时，该线程就会进入阻寒状态，如果想进入就绪状态就必须要等到这个阻塞的I/O方法返回。

* 当线程调用了某个对象的wait()方法时，也会使线程进入阻塞状态，如果想进入就绪状态就需要使用notify()方法唤醒该线程。

* 当线程调用了Thread的sleep(long millis)方法时，也会使线程进入阻塞状态，在这种情况下，只需等到线程睡眠的时间到了后，线程就会自动进入就绪状态。

* 当在一个线程中调用了另一个线程的join()方法时，会使当前线程进入阻塞状态，在这种情况下，需要等到新加入的线程运行结束后才会结束阻塞状态，进入就绪状态。

需要注意的是，线程从阻塞状态只能进入就绪状态，而不能直接进人运行状态，也就是说，结束阻塞的线程需要重新进入可运行池中，等待系统的调度。

5. 死亡状态(Terminated)

如果线程调用stop()方法或nun()方法正常执行完毕，或者线程抛出一个未捕获的异常(Exception)错误(Error)，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。


## 如何实现线程的同步
1. 同步方法，使用 synchronized关键字，可以修饰普通方法、静态方法，以及语句块。

2. 同步代码块，用synchronized关键字修饰语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步

3. 使用特殊域变量(volatile)实现线程同步。

4. 使用重入锁实现线程同步，在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。

5. 使用局部变量实现线程同步，如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。  

## 线程间的通讯方式
### 1.什么是线程通信
线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。这些线程之间就需要互相协调，这个过程被称为线程的通信。
### 2.为什么需要线程通信
线程是操作系统调度的最小单位，有自己的栈空间，可以按照既定的代码逐步的执行，但是如果每个线程间都孤立的运行，那就会造资源浪费。
在现实中，我们需要这些线程间可以按照指定的规则共同完成一件任务。

### 3.线程通信的方式种类
* 共享内存：线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。（volatile共享内存）

* 消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。（wait/notify等待通知方式、join方式）

* 管道流（管道输入/输出流的形式）

